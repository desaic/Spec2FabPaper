%%% template.tex
%%%
%%% This LaTeX source document can be used as the basis for your technical
%%% paper or abstract. Intentionally stripped of annotation, the parameters
%%% and commands should be adjusted for your particular paper - title,
%%% author, article DOI, etc.
%%% The accompanying ``template.annotated.tex'' provides copious annotation
%%% for the commands and parameters found in the source document. (The code
%%% is identical in ``template.tex'' and ``template.annotated.tex.'')

\documentclass[annual]{acmsiggraph}


\TOGonlineid{45678}
\TOGvolume{0}
\TOGnumber{0}
\TOGarticleDOI{1111111.2222222}
\TOGprojectURL{}
\TOGvideoURL{}
\TOGdataURL{}
\TOGcodeURL{}

\usepackage{amsfonts}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{multirow}
%\title{A Graph-Based Reduction for Optimal Material Assignment}
\title{A Reduced Representation for Computational Fabrication}
% A reduced representation for computational fabrication
%\title{Spec2Fab: A Graph-Based Reduction for Computational Fabrication Algorithms}
% High-fidelity Mapping From Specification to Fabrication
% A graph-based material assignment
% reduction-simulation-optimization
% Exploring the space of computational fabrication algorithms

\author{}
\pdfauthor{}

\keywords{}

\newcommand{\note}[1]{\marginpar{\LARGE $\spadesuit$}
			$\spadesuit$ {\bf #1} $\spadesuit$}

\begin{document}

 \teaser{
   \begin{subfigure}[b]{0.2\textwidth}
	\centering
    	\includegraphics[width=\textwidth]{figure/globe.png}
      	\caption{}
        \label{teaser:original}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.2\textwidth}
                \centering
    	\includegraphics[width=\textwidth]{figure/map.png}
                \caption{}
                \label{teaser:ours}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.2\textwidth}
                \centering
    	\includegraphics[width=\textwidth]{figure/chess.png}
                \caption{}
                \label{teaser:makerbot}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.2\textwidth}
                \centering
    	\includegraphics[width=\textwidth]{figure/caustics.png}
                \caption{}
                \label{teaser:objet}
        \end{subfigure}
        \caption{3D-printed objects with various effects designed by our API.
        	(a)(b)textured models,(c)a model with a subsurface-scattering resembling a marble chess-board.
        	(d)a caustics image projected by an object under proper lighting}\label{teaser}
 }

\maketitle

\begin{abstract}
Digital fabrication allows to virtually design objects and then translate them to the corresponding physical equivalents.
With the increasing popularity of multi-material 3D printing, these objects can be composed from multiple materials that have different properties.
A key computational problem is how to compute a spatially varying material distribution that yields specified real-world behavior of the object.
During the last few years a number of instances of this problem have been examined that tackle different aspects of object behavior, e.g.,  appearance or elastic deformation.
In this paper, we propose an abstraction mechanism that simplifies the design, development, and implementation of these processes.
Our solution relies on two data structures: a graph-based reducer network that efficiently parameterizes the space of material assignments and a tuner network that describes the optimization process to achieve desired material assignment. A corresponding API provides a natural way of specifying user-defined translation processes and the desired object.  
We illustrate the utility of our framework by showing implemented fabrication algorithms as well as the corresponding manufactured results.
\end{abstract}

\keywordlist

\TOGlinkslist

\copyrightspace

%\note{Teaser should be all different results produced using spec2Fab, texture, subsurface scattering, caustics etc...}
\section{Introduction}
% state of the world
% Desktop Manufacturing is taking off
% Stress multi-material 3D printing
Computational design and 3D printing have been gaining attention among the general public but also within the computer graphics community.
Computational design methods allow a wider audience to create custom objects and parts.
These created designs can be automatically fabricated using a number of different 3D printing technologies.
The range of the printing materials constantly expands and it is now possible to create and fabricate heterogeneous objects that combine a number of different materials.

% transitioning to the need
When designing multi-material objects to be fabricated, users have to directly provide a material for each point inside of the object volume.
In practice, an object is described using a collection of meshes, where each mesh is assigned a desired printing material.
This process can be in many cases non-intuitive and users need to have access to all printing materials to ensure that the physical object looks and behaves the way they want.
Even more importantly, objects are designed for a specific 3D printer and a set of materials. There is currently no way to translate between different printer-specific designs.

% the need
% Users would like to specify high-level goals for the object rather the direct specification of materials
% some examples:
There is a need to for a computationally efficient and general process that translates virtual objects specified in device-independent manner in terms of their mechanical and appearance properties to output-device-specific computer programs that produce the best possible approximation of these digital objects.
Specifying objects in terms of their physical properties, for example, albedo values, rather than specific materials is much more user-intuitive.  However, this is still one of the most important unsolved problems in digital direct manufacturing.

% Other approaches
% There is already of number of algorithms for specific solutions.
% But each of them is custom, they are difficult to extend and modify, combine
Computer graphics researchers have started designing algorithms for specific instances of this process, for example, subsurface scattering~\cite{Hasan:2010,Dong:2010} or deformation properties~\cite{Bickel:2010}. However, each of these instances is custom and difficult to extend or modify. Combining different process instances, e.g., designing and fabricating an object that has both desired reflectance and deformation is currently not possible.

% There is a general structure of these algorithms that has gone exploited: reduction, optimization, simulation
% This suggests that you can build a system for integrating/combining, but also exploring modifying individual pieces
We observe that all these process instances share a similar structure. They rely on the ability to accurately simulate the physical properties of an object given its geometry and material assignment. They use this simulation within the optimization framework to search the space of all possible material assignments in order to find the one that best reproduces the desired properties. Unfortunately, due to the combinatorial nature of the search space the naive optimization approach is not tractable. For example, when the printing volume has $N$ voxels and each of these voxels can be assigned to one of $M$ base materials, the search space has $N^M$ dimensions. To overcome this problem, the search space is reduced to a lower-dimensional space using a reduction model. The goal of the reduction step is to shrink the search space as much as possible without pruning out good solutions.

The reduction-optimization structure suggests that it is possible to provide a more general abstraction mechanism for translating specifications to fabrication instructions.
In this paper we take the first step in achieving this goal. In particular, we and focus on the solution for building algorithms that compute optimal material assignment. Our solution is built around two data structures. The reducer network is graph-based framework that allows us to parameterize the spaces of material assignments. The tuner network is a data structure for specifying the optimization process. Our solution also provides an API that for intuitively specifying the desired object, the simulation, and these two data structures. Our approach has a number of advantages: different components of the process can be easily replaced, components can be reused across different, different parameterizations of the material domain and optimization strategies can be easily explored. 

We show that this framework supports a number of different computational design and fabrication scenarios. We demonstrate the results of these algorithms and we also demonstrate that different specifications can be combined.  


% In this paper we propose a system (that exploits this structure) for building algorithms that compute optimal material assignment for computational fabrication
% this build around two data-strictures: the reducer network (parameterizing the space of material assignments)  and the tuner network (the data structure for specifying the optimization). We also have an API.

%Computational fabrication couples new digital manufacturing techniques with novel numerical algorithms to produce objects with remarkable physical characteristics. These methods are of great interest in computer graphics for two reasons: First, they provide us with  a new class of output devices which can render into real-life and second, they yield valuable insight into the accuracy of our numerical models of the world.

%In this paper we focus on a fundamental problem in producing any such custom object:  optimal material assignment. Given an object one must find a spatially varying material distribution that satisfies some given criteria. The algorithms that solve these problems are often complicated to develop, implement, test and modify. We provide a new graph-based framework which decomposes such problems into a small set of constituent components alleviating the above issues as well as facilitating the development and testing of new methods.

\section{Related Work}

% Computational Fabrication
% BRDFs: Weyrich, Matusik,
% Refractive: Papas, Architectural Caustics, Finsch
% Subsurface Scattering: Dong, Hasan
% Shadows: Pauly (Shadow Art), ShadowPix
% Deformation: Face Cloning, Balloons, Bickel
% Albedo/Shading: Reliefs
% Geometry compression: Digital Bas-Relief from 3D Scenes

% Shade trees:
% abstract shade trees
% Yam, Siggraph Asia 2011

Here we will review previous algorithms for solving the optimal material assignment problem . We divide this review into two broad categories, optimizing for desired optical properties and optimizing for desired mechanical properties. We conclude by commenting on the similarities between these approaches.

Optimizing and manufacturing objects with desired optical characteristics is a popular problem in computer graphics. Building objects which embed images in their caustics has been explored by Finch \textit{et al.} ~\shortcite{Finckh:2010} and Papas \textit{et al.}\shortcite{Marios:2011}. Optimization based approaches have also been employed to control the subsurface scattering of printed 3D models ~\cite{Hasan:2010}. These methods have also been extended to optically decrypt hidden images ~\cite{Papas:2012}. Finally, optimal shadow casting surfaces have been produced which emulate a given set of input images ~\cite{Bermano:2012}.

Fabricating objects with desired mechanical characteristics has been explored less in the literature. Some recent examples include simulating and manufacturing layered composites ~\cite{Bickel:2010} as well as the design and construction of balloons with a prescribed shape while inflated ~\cite{sko:2012}. Finally, material optimization has been employed to create mechanical clones of human faces ~\cite{Bickel:2012}.

\autoref{tb:algorithms} shows the coordinate reduction methods as well as the optimization schemes used in all cited works. A motivating observation for this research is that, despite different applications, these previous works share, not only a common methodology, but a set of common reduced coordinate components. These, in conjunction with (often off-the-shelf) optimization techniques form new material assignment algorithms. This suggests that one could find a small set of components that can be tied together to synthesize existing and new methods. Similar approaches have already proven useful for creating complex texture shading examples ~\cite{Cook1984}. Our goal in this paper is to produce an analogous mechanism for material assignment problems.
\begin{table*}[htp]
\centering
\caption{The goal type, reduction type and optimization used by previous fabrication works.}
\begin{tabular}{clll}
\hline
\textbf{Paper} & \textbf{Goal} & \textbf{Reduced Coordinates}  & \textbf{Optimization} \\
\hline
~\cite{Bickel:2010}& Deformation & Layered Materials  & Branch and Bound \\
~\cite{Finckh:2010} & Optical (Caustics) & B-Spline Surface & SPSA \\
~\cite{Hasan:2010}& Optical (Subsurface) & Layered Materials & Branch and Bound\\
~\cite{Marios:2011} & Optical (Caustics) & Piecewise Constant Tiles & Simulated Annealing \\
~\cite{Bermano:2012} & Optical (Shadows) & Height Field & Custom/Simulated Annealing \\
~\cite{Bickel:2012} & Deformation &  Height Field &  Newton-Raphson \\
~\cite{Papas:2012} & Optical & Piecewise Constant Tiles & Simulated Annealing \\
~\cite{sko:2012}& Deformation & Triangle Mesh & ALM \\
\hline
\end{tabular}
\label{tb:algorithms}
\end{table*}
%\subsection{Simulation of the Appearance of Ink Combinations}
%\cite{Matusik:2009} built a system
%for the measurement of Bidirectional Reflectance Distribution Functions (BRDFs) and were able
%to acquire BRDFs for both single-layer and multi-layer ink printouts (e.g., an ink covered by a
%varnish layer). They then acquired a database of many different combinations of ink layers (up to
%seven layer combinations were considered). However, they did not develop a method to simulate
%the appearance of arbitrary ink layers. They were able to interpolate the appearance by spatially
%multiplexing small tiles of different base combinations. By linearity of light transport, the simulation
%of the combined appearance was reduced to linear combinations of the base BRDFs.
%simulation method for the appearance of translucent materials \cite{Hasan:2010}.
%They
%built a measurement system for estimating multiple-scattering in homogeneous material slabs. They
%measured both transmission and refection for a set of base materials used by the OBJET Connex
%multi-material printer.
%Using these measurements, our simulations framework was able to predict
%diffuse reflections and transmissions in multi-layered translucent objects composed of base material
%layers.
%In the proposed research, we will extend these methods to cover the complete appearance of
%volumetric materials that accounts for both directly reflected light and light scattering within the
%material volume.
%We will use efficient simulation methods that allows us to simulate the appearance
%of complex structures composed from these base materials. We developed an initial framework for
%simulating behavior of multi-layered materials, where each layer is a homogeneous base material.
%Then we extend this simulation to materials in which each voxel is made of a different measured
%material. Since this general simulation is expensive and requires path-tracing algorithms, we used
%algorithms that are based on fast numerical integration of our low-dimensional representations
%and the use of pre-computation, similar to pre-computed light transport approaches \cite{Sloan:2002}.
\section{Contributions}
The overall contribution of our work is a flexible framework for the construction of material assignment for computational fabrication algorithms. Our second contribution is the ``Reducer Network'',  a graphical data structure which describes both the geometric partitioning and material parameterization of  a given object. We couple this with a ``Tuner Network'' which automatically tunes the parameters of the Reducer Network to produce a fabricable object. Ultimately  we use these data structures to build an extensible, easy to use API which can produce numerous material assignment algorithms from a set of primitive operations.
% 1. Flexible framework for material assignment
% 2. Data structures
% 3. API
\section{Methods}
Below we will describe the key components of our framework and its associated API. We begin by describing the data structures that tie our framework together, the Reducer Network and the Tuner Network. We will then show how these two components interact to provide a compact graphical description of the material assignment problem. Finally, we will detail the basis set of components that we use to produce a wide-range of fabrication algorithms.
\subsection{The Reducer Network}
Computing material assignments at output device resolution is computationally inefficient. Because of this, material assignments are computed  using a reduced representation. We specify this representation using a Reducer Network.  This structure is conceptually similar to those used in programmable shading systems (e.g. ~\cite{Cook1984}, Maya Shader Networks) . However these systems are primarily concerned with assigning known materials and textures to an object's surface whereas we are seeking a volumetric assignment of (as yet) unknown materials. In order to accomplish this task we build a directed, acyclic graph which has the object's surface geometry as its root node. We define two classes of nodes, geometry nodes and parameterization nodes. A geometry node takes a volumetric region as input and produces a partition of unity of this region as output. The leaf nodes of our graph are the parameterization nodes which associate a material assignment function of the form $\lambda\left(x,y,z, \boldsymbol{\theta}\right)$ to an input volumetric region.
$\lambda$ can either output material parameters or a discrete material assignment for a spatial point $\left(x,y,z\right)$ given some parameters, here denoted by $ \boldsymbol{\theta}$. We allow our material assignment nodes to assign a void material to regions of the mesh. This allows us to treat surface displacements and material assignments in a unified fashion. Because the network describes a nested set of partitions of unity we can efficiently perform material queries by passing a query point through the network until it arrives at a parameterization node. We note that Reducer Networks do not inherently enforce material continuity between disjoint regions of the object, however, for material assignment problems this is neither required nor desired.

\autoref{fig:red1} shows an example Reducer Network which can be constructed with the following pseudo-code.
%There are may be a better place to put the pseudo code
%\begin{program} can't figure out how to put it into a box
\begin{verbatim}
stratum->addInput(inputNode,0);
column->addInput(stratum, 0);
//add layered material to each column
for(ii =0;ii<column->getNOutput();ii++){
  layer = new LayeredMaterial(2);
  layer->addInput(column,ii);
}
uniform = new UniformMaterial(0);
uniform->addInput(stratum,1);
\end{verbatim}
%\caption{The Hello World! program in Java.}
%\end{program}

\begin{figure}[h]
\includegraphics[scale=0.3]{figure/redNetwork.pdf}
\caption{A Reducer Network used to produce one of our results.
The input geometry is sliced into two layers with the stratum partition node.
The top slice is then partitioned into columns. Each column is assigned
a stack of material layers.}
\label{fig:red1}
\end{figure}

\subsection{Tuners}
We define tuners as an abstract interface between a Reducer Node and an optimization algorithm.  Specifically a tuner is comprised of an optimization scheme, an error metric and a goal. Each tuner is attached to a specific geometric node in the Reducer Network. It then acts to optimize, or tune, the free variables associated with the subtree rooted at this node. One can think of this as a self-tuning shader network.  This organizational structure allows us to easily optimize subdomains of our object using different tuners. We provide a mechanism for scheduling tuner execution thus allowing both serial and parallel processing.
\subsection{Tuning the Reducer Network}
\autoref{fig:tuner0} shows a typical workflow for the tuner.
\begin{figure}
\includegraphics[width=0.4\textwidth]{figure/tuner0.png}
\caption{Typical workflow for a Tuner.}
\label{fig:tuner0}
\end{figure}
A Tuner initializes its optimization procedure by querying the search space from its Reducer Node.
The Reducer Node computes the search space by traversing its sub-tree and collecting
free variables. The search space specifies the number of free variables, the type of each free variable
(discrete or continuous) and the bounds of these variables.
With the search space specified, the Tuner's optimization subroutine executes.
The optimization subroutine may ask for additional information such as
the error value of a variable assignment and the gradient. These queries are answered
with call-back functions set up by the Tuner before executing the optimization subroutine.
The call-back function typically performs the following three steps:
using Reducer Node to convert a variable assignment back to material assignment
function $\lambda$, running a simulation with the new material assignment
and computing errors given the simulated result.
We note that our material function $\lambda$ can
be efficiently evaluated by traversing the Reducer Network.
%I need to think about this
%We note that gradient computation of our material function $\lambda$ can also
%be performed by efficiently traversing the Reducer Network.
\subsection{Tuner Network}
For many fabrication problems, tuners cannot act in isolation. For instance,  occasionally the best material at a given point in space is dependent upon the material assignment at nearby locations.  Tuning the free variables as if they were independent usually yields unsatisfactory results. Therefore, we allow the tuners to share information according to a user-specified graph structure.  This allows our framework to be interfaced with a wide range of existing graph based optimization and inference algorithms. For example, consider the Floyd–Steinberg dithering algorithm in which the error at a given pixel is distributed
to $4$ of its neighbors (right, lower left, down and lower right).  The graph structure of this algorithm is illustrated in Figure~\ref{fig:tuner}. The tuner is combined with the Reducer Network in Figure~\ref{fig:red1}. A simplified view of the combined graph is shown in Figure~\ref{fig:combine}. Executing each tuner in order is equivalent to running the Floyd–Steinberg dithering algorithm.

The Tuner graph can be constructed using the following pseudo-code
%Can't figure out how to put it into a box
\begin{verbatim}
for(ii=0;ii<column->resolution;ii++){
  for(jj =0;jj<column->resolution;jj++){
  //add 4 neighbors for each tuner
      tuner[ii][jj].nbr.push_back(ii,jj+1);
      tuner[ii][jj].nbr.push_back(ii+1,jj-1);
      tuner[ii][jj].nbr.push_back(ii+1,jj);
      tuner[ii][jj].nbr.push_back(ii+1,jj+1);
    }
  }
}
\end{verbatim}

\begin{figure}[h]
\includegraphics[scale=0.3]{figure/tuner.pdf}
\caption{A sample Tuner Graph for the Floyd–Steinberg dithering algorithm.}
\label{fig:tuner}
\end{figure}

\begin{figure}[h]
\includegraphics[scale=0.3]{figure/netAndTuner.pdf}
\caption{Combined graph for the error diffusion example.}
\label{fig:combine}
\end{figure}
%\section{System Description}
%The software framework (shown in Figure~\ref{fig:framework}) is composed of
%a set of software
%modules that can be easily modified or exchanged. The first component
%of this framework is an output-device-independent description API
%that allows the user to specify any physical object in terms of its physical
%properties such as geometry, mechanical behaviors, and appearance.
%The framework will also provide physically-based
%simulation tools that accurately predict the behavior of our output device.
%The goal of the optimization module is to search through
%the space of possible device outputs and deliver one that best matches the
%desired model. In order to evaluate the quality of the match between the
%simulation output and the desired model we need to develop appropriate
%comparison metrics. Finally, a central component of our framework is
%a reduction model which makes the optimization problem tractable by
%reducing the search space as much as possible.
%The reduction model can specified by experts or deduced from a
%set of examples. Next, we will describe each element of the framework in
%more detail.
%\begin{figure}
%\includegraphics[width=0.45\textwidth]{figure/framework.pdf}
%\caption{API overview. The diagram will become nicer.}
%\label{fig:framework}
%\end{figure}
%\subsection{Input API}
%Our input API handles three tasks: specifying an optimization problem,
%maintaining a material library and configuring existing modules of
%the optimization process.
%An overview of the three components of our API is shown in Figure~\ref{fig:inputAPI}
%
%\begin{figure}
%\includegraphics[width=0.45\textwidth]{figure/inputAPI.pdf}
%\caption{Input API. The diagram will become nicer.}
%\label{fig:inputAPI}
%\end{figure}
%
%Our input API allows a designer to either
%define material properties for sections of an object
%or specify behavior of an object.
%The designer
%can use functions to describe properties such as reflectance (e.g., BRDFs, BSSRDFs),
%stiffness, or other spatially varying properties.
%Although it is possible to define the object directly by only specifying material
%properties, intuitive user
%interfaces will aid in specifying the objects and their properties
%in terms of intuitive metaphors.
%For example, the elastic properties of an object can be specified by a set of
%example displacements from the rest pose and the corresponding applied forces.
%\subsection{Search Space Decomposition and Reduction}
%Our framework includes an optimization component that
%searches through the space of possible device inputs
%to find the one that best reproduces
%the desired object. Unfortunately, this search space
%is usually intractable. For example, when the printing
%volume has N voxels and each of these voxels can be
%assigned to one of M base materials, the search space
%contains $N^M$ choices.
%To overcome this problem, we decompose the search
%space into similar subproblems and also reduce
%the search space to a lower-dimensional space using a reduction model.
%The goal of the reduction step is to
%shrink the search space as much as possible but at the
%same time not to prune out good solutions. The low-dimensional space produced by the
%reducer can be defined in two different ways. First, a reduction model can be explicitly specified by an expert, for
%example, by defining structures of base materials and rules how different base materials can be combined together.
%In this paper, all reduction models are manually specified by us.
%The second way to specify a reduction model is implicit. In this case, the user provides a set of examples of
%valid material structures. Then, a machine learning algorithm infers both basic material structures and the rules
%for combining them. The optimization framework can be further improved by employing techniques that cluster
%partial solutions that yield similar output properties, avoiding combinatorial explosion of the search space.
%Furthermore, we can employ bounds on the solution based on physical constraints of the base materials.
%\subsection{Optimization}
%Our optimization component is an interface to
%existing standard optimization techniques
%such as simulated annealing, variational inference and
%Markov Chain Monte Carlo methods,
%as well as custom optimization algorithms implemented
%by more advanced users.
%\subsection{Simulation}
%Another key step in the process of converting abstractions to physical output is being able to
%simulate what an output device is going to generate given a well-defined input.
%A simulation allows the user to preview how the output will look and behave.
%This simulation is a generalization of the print-preview function
%available in word processing applications.
%As physical output generation might be costly or time-consuming,
%it is extremely beneficial for users to be able to preview the output and make immediate changes to the design.
%That means that the simulation must accurately predict the output.
%It's necessary to develop very efficient and accurate rendering
%and finite element simulation packages. Since we run the simulation multiple times within the optimization method
%we can cache and reuse partial simulation results, speeding up the evaluation process at least 10-100 times.
%Furthermore, we will ensure that the simulation is accurate by measuring properties of the printing materials and using
%these measurements to estimate the parameters of data-driven material models (e.g., for elasticity, reflectance).
%
%\section{Built-in Components}
%We provide a built-in library that handles common tasks such as assigning texture,
%simulating deformation, and optimizing for a stacking.
%\subsection{Generator}
%Generator uses a reduced representation
%of material assignments.
%Each generator is defined over a domain in the input shape.
%We provide a few basic generators and a composition operator.
%Let the input shape be over a domain $\Omega$.
%The composition of two generators $G_2\circ G_1$ is implemented by
%first letting $G_1$ reduce over a domain $\Omega_1$ and
%then letting $G_2$ reduce $\Omega_2 = \Omega-\Omega_1$.
%An example is shown in Figure~\ref{fig:genCompose}
%\begin{figure}[h]
%\includegraphics[scale=0.2]{figure/genCompose.png}
%\caption{Composition of two generators. $G_1$ is a fine-grained
%surface voxelization and $G_2$ is a very coarse inner
%grid.}
%\label{fig:genCompose}
%\end{figure}
%
%We will provide the following generators.
%\begin{enumerate}
%\item A generator that uses a uniform grids with homogeneous
%material in each grid cell. (A foam structure is treated as one homogeneous material).
%\item A generator that decomposes a mesh into columns of stackings.
%\item A polynomial spline for outline of a material.
%\end{enumerate}
%We use composition of the above basic generators to make the examples in
%the result section.
%\subsection{Simulator}
%\begin{enumerate}
%\item Physics simulator with FEM, rigid body simulation
%and simple collision resolution.
%\item nVidia optiX to do photon mapping for caustics. Maybe also BRDF and shadows.
%We need to look at its speed.
%\item local computations such as reflectance and local mechanical properties given a stacking.
%\end{enumerate}
%
%\subsection{Metric}
%Optionally returns a gradient represented as an array of signed floats.
%\begin{enumerate}
%\item Compare a mesh and its deformed state. There is one-to-one correspondence of
%vertices.
%\item compare two images
%\item compare two real numbers such as weight and bouncing height.
%\end{enumerate}
%
%\subsection{Optimizer}
%\begin{enumerate}
%\item MCMC, Simulated Anealing, SPSA
%\item Branch and bound (plus clustering of similar configurations)
%\item (Optional) reinforcement learning, deep neural networks...
%\end{enumerate}
%
%\section{Programming with Our API}
%A casual user mostly make function calls to an existing
%manager to pass data and to run the optimization.
%More advanced user can configure the manager to achieve more specific requirements.
%For example, he can swap out an existing optimization module to achieve a better accuracy or
%a faster speed.
%A professional user can implement more modules when he wants to deal with new
%material properties that are not handled by our built-in library. In that case,
%he needs to know what value the new property is in print materials, he needs to know
%how to simulate for the new property, and how to measure error of the new property.
%
%In below, we provide code snippets that handles three common tasks
%that we expect a moderately advanced user would write.
%
%Code examples:
%To generate textured model:
%\begin{verbatim}
%Manager manager;
%manager.loadMaterialLib("material_file");
%manager.setGenerator(
%  new HeightFieldGenerator());
%manager.setSimulator(colorSimulator());
%manager.setMetric(someColorMetric());
%manager.setOptimizer(
%  simulatedAnealing);
%  //or e.g. gradientDescent
%Objective obj;
%Scene scene;
%TexturedShape shape("filename");
%TexturedShape goal("filename1");
%scene.addShape(shape);
%obj.setScene(scene);
%obj.setGoal(goal);
%manager.addObjective(obj);
%\end{verbatim}
%
%To optimize BRDF for a particular camera view point and lighting.
%\begin{verbatim}
%scene.setCamera(camera);
%scene.addLight(light);
%manager.setGenerator(stackingGenerator);
%manager.setSimulator(brdfSimulator);
%manager.setMetric(someImageMetric);
%Shape shape("filename"),
%Image goal("filename1");
%\end{verbatim}
%
%Defining elasticity properties
%by specifying deformation
%reaction to a force applied to a point.
%
%\begin{verbatim}
%force = new Force(pos, dir, shapeID);
%constraint = new Constraint(
%    FIX_VERTEX, vertexList, shapeID));
%
%scene.addForce(force);
%scene.addConstraint(constraint);
%Shape goal;
%manager.setSimulator(femSimulator);
%\end{verbatim}

%\note{I think we should just go with the results we have, texture etc... show the reducer network, tuner network, simulated results and manufactured result (if you have them}
\section{Results and Discussion}
Table~\ref{tab:built-in} shows a list of nodes implemented in our framework. With this set of nodes we can reproduce all work previously discussed. This validates our assertion, that the space of fabrication  algorithms can be spanned effectively using the Reducer and Tuner networks. Secondly it illustrates how we can leverage component reuse to quickly create such algorithms.\autoref{tab:example} lists the components of the framework used to recreate each example.

For each example, we show the target, the simulated output, and the fabricated result in Figure~\ref{tab:result}.


\begin{table*}
\centering
\begin{tabular}{lc}
\hline
\textbf{Reducer Node} & \textbf{Description} \\
Geometry Nodes &\\
\hline
InputMesh & Loads shape to which materials will be assigned\\\
Stratum & Divides an input volume into an outer layer of given thickness and an interior blob\\
Column & Divides an input volume into a number of columns\\
\hline
Material Nodes &\\
\hline
ConstantMaterial & Assigns a constant material to an input volume \\
LayeredMaterial &  Assigns a layered set of materials to an input volume \\
QuadLayerMaterial & Like LayeredMaterial, but the materials are separated by a quadrangle\\
SubdivSurfMateral & Like LayeredMaterial, but the materials are separated by a subdivision surface \\
\hline
\end{tabular}
\caption{Components we implemented and used in the experiments.}
\label{tab:built-in}
\end{table*}

\begin{table*}
\centering
\begin{tabular}{llll}  %error metric is not interesting
\hline
\textbf{Example} & \textbf{Reducer Nodes} & \textbf{Simulator} & \textbf{Optimization}\\
\hline
Texture& Stratum, Column, LayeredMaterial & reflectance & Error diffusion \\
Subsurface scattering& Stratum, Column, LayeredMaterial & reflectance , transmittance & Branch and bound\\
Caustics 1 & Column, QuadLayerMaterial & & SA \\
Caustics 2 & Column, SubdivSurfMaterial & caustics & SPSA \\
Deformation & Column, LayeredMaterial& elasticity & Branch and bound\\
\hline
\end{tabular}
\caption{Example pipelines constructed for our experiments.}
\label{tab:example}
\end{table*}

\begin{table*}
\centering
\begin{tabular}{|p{2cm}|l|l|l|}
\hline
\textbf{Example} & \textbf{Target} & \textbf{Simulation} & \textbf{Printed Result}\\
\hline
Texture&  \includegraphics[width=3cm]{figure/globeTarget.png}& \includegraphics[width=3cm]{figure/globeSim.png}
& \includegraphics[width=3cm]{figure/globe.png}\\
&  \includegraphics[width=3cm]{figure/mapTarget.png}& \includegraphics[width=3cm]{figure/mapSim.png}
& \includegraphics[width=3cm]{figure/map.png}\\
\hline
Subsurface Scattering&  \includegraphics[width=3cm]{figure/chessTarget.png}& \includegraphics[width=3cm]{figure/chessSim.png}
& \includegraphics[width=3cm]{figure/chess.png}\\
\hline
Caustics &  \includegraphics[width=3cm]{figure/causticsTarget.png}& \includegraphics[width=3cm]{figure/causticsSim.png}
& \includegraphics[width=3cm]{figure/caustics.png}\\
\hline
\end{tabular}
\caption{Fabricated objects.}
\label{tab:result}
\end{table*}

\subsection{Textured Model}
Here we design an algorithm to print textured models using a two material printer. We expand the set of printable colors by stacking translucent materials using the LayeredMaterial node. We then applied dithering using this expanded gamut.
The first two rows in \autoref{tab:result} shows the results of this method.
\subsection{Subsurface Scattering}
We replicated \cite{Hasan:2010} using our framework.

\subsection{Refractive Caustics}
We have also implemented two algorithms for computing goal-based caustics;  ~\cite{Marios:2011} and ~\cite{Finckh:2010}.
The first version of this algorithm computes  a set of micro-lenses which produce the desired caustic image.
The optimization applies simulated annealing to permute the location of these micro-lenses in order to construct a smooth surface.
Each tuner is connected to its four neighbors.
During the execution of an individual tuner, the optimization algorithm makes a randomized decision about
 whether or not to swap its micro-lens with one of its neighbors.
The tuners are run in sequence until some convergence criteria is met.
Of note is the fact that this method does not require a simulation algorithm.
Despite this, it is still implementable within our framework.

In the second algorithm, we use subdivision surfaces to represent a smooth caustic surface.
This is in contrast to the potentially discontinuous surface in the method above.
The original algorithm used a B-spline surface representation, however we have replaced this with a subdivision surface.
We also replace the specialized renderer from the original publication with a generic, fast caustics rendering technique ~\cite{Yuksel:2009}. Our algorithm took 6 hours to finish with $4000$ control points for the model and $600\times 600$ resolution for the caustic image.  A picture of our printed result under desired lighting is shown in \autoref{fig:caustic}.
\begin{figure}
	\centering
 	\includegraphics[width=0.3\textwidth]{figure/caustic.jpg}
\caption{Teapot with a caustic image.}
\label{fig:caustic}
\end{figure}

\subsection{Subsurface Scattering and Deformation}
We first replicated \cite{Bickel:2010} to print materials with specified elasticity. We then combined it with subsurface scattering
matching to print material that approximates both the subsurface scattering property and the deformation behavior. The result is shown in Figure~\ref{fig:deform}. In our case we perform coupling at the tuner level by alternating tuner execution for the two
separate problems. Here we see that our framework facilitates the creation of new fabrication problems by allowing easy reuse of previous work and also providing a ``playground'' in which one can explore different computational approaches. \autoref{fig:err} contains two error plots showing that the subsurface scattering and deformation errors decrease after each tuner iteration.


%We tried different combinations of generators in this experiment.
%We compared the performance of these different generator
%in terms of run-time and error.
%\begin{enumerate}
%\item Spline for top layer, fine-grained voxelization for mid layer
%and a coarse grid for bottom layer.
%\item Voxels for top layer, splines for middle layer and a coarse
%bottom layer.
%\item Find-grained voxels for top layer and coarse grid for bottom layer.
%\end{enumerate}

\begin{figure}
\begin{subfigure}[b]{0.3\textwidth}
	\centering
 	\includegraphics[width=\textwidth]{figure/slab_origin.png}
   	\caption{}
    \label{fig:deformPhoto}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.3\textwidth}
    \centering
  	\includegraphics[width=\textwidth]{figure/slab_deform.png}
    \caption{}
    \label{fig:deformPrint}
\end{subfigure}
\caption{Simutaneously matching appearance and deformation.
(a)Original slab of a particular looking. (b)printed slab
with the same looking and desired deformation.}
\label{fig:deform}
\end{figure}


\begin{figure}
\begin{subfigure}[b]{0.3\textwidth}
	\centering
 	\includegraphics[width=\textwidth]{figure/error.pdf}
   	\caption{}
    \label{fig:ssErr}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.3\textwidth}
    \centering
  	\includegraphics[width=\textwidth]{figure/error.pdf}
    \caption{}
    \label{fig:deformErr}
\end{subfigure}
\caption{Error plots for
optimizing subsurface-scattering and deformation properties
iteratively. (a)Subsurface scattering errors. (b)Deformation errors.}
\label{fig:err}
\end{figure}

%\subsection{New Examples for Mechanical Properties}
%%Ball bounce to certain height. We used a higher resolution
%%grid for the out layer and very low resolution
%%for the inner mesh.
%%
%%A plot of bounce height after each iteration.
%%The height and desired height is plotted in Figure~\ref{fig:ball}
%%\begin{figure}
%%	\centering
%% 	\includegraphics[width=0.3\textwidth]{figure/ballHeight.pdf}
%%\caption{Simulated height per-iteration of a ball bouncing after free-falling at 1 meter height.
%%	Redline is desired height.}
%%\label{fig:ball}
%%\end{figure}
%
%
%A loaded die as shown in Figure~\ref{fig:die}.
%This example is a showcase for a global optimization algorithm
%because a local change of material assignment will influence the global behavior.
%We used very high resolution grid for the surface to match texture
%of a die. The inner lay has only $3\times 3$ resolution.
%\begin{figure}
%	\centering
% 	\includegraphics[width=0.25\textwidth]{figure/die.png}
%\caption{A printed loaded die}
%\label{fig:die}
%\end{figure}
%It has a certain probability to land on "1".
%A table of probability distribution of landing on each side
%is shown in Table~\ref{tab:dice}.
%
%\begin{table}
%\centering
%  \begin{tabular}{ |c| p{0.7in} | p{0.7in} | }
%  \hline
%  face & simulated probability & measured probability\\
%  \hline
%  1 & 0.5 & 0.5\\
%  \hline
%  2 & 0.1 & 0.1\\
%  \hline
%  3 & 0.1 & 0.1\\
%  \hline
%  4 & 0.1 & 0.1\\
%  \hline
%  5 & 0.1 & 0.1\\
%  \hline
%  6 & 0.1 & 0.1\\
%
%  \hline
%  \end{tabular}
%  \caption{Simulated and measured dice probability}
%  \label{tab:dice}
%\end{table}
%
%A plot of simulated probability of landing on "1" after each iteration
%is shown in Figure~\ref{fig:dieErr}.
%
%\begin{figure}
%	\centering
% 	\includegraphics[width=0.3\textwidth]{figure/die.pdf}
%\caption{Probability of die landing on 1 after each iteration.}
%\label{fig:dieErr}
%\end{figure}
%
%Printer:objet, ours.
%
%More ideas:
%balancing bird with texture.
%%%\section{Possible Extension}
%%%UI to specify input deformation.
\section{Limitations and Future Work}


\section{Conclusion}
We have presented Spec2Fab a graph based framework for building fabrication algorithms. By using the Reducer and Tuner Networks we reveal similarities between different fabrication algorithms allowing us to maximize component reuse. This both accelerates and eases implementation. We have also shown that Spec2Fab facilitates the development and testing of new algorithms since Spec2Fab makes exploring the space of fabrication problems more efficient.
\section*{Acknowledgements}

\bibliographystyle{acmsiggraph}
\bibliography{paper}
\end{document}
